// -*-C-*- // utilisation du mode C dans emacs

#define PI 3.14159265358979323846
#define DEUX_PI 6.283185307179586
#define R 1.0
#define G 0.5
#define B 0

/* NB_SOURCES doit être défini sur la commande de compilation */

struct vertexOutputsTEX
{
  float4 HPos	    : POSITION;
  float4 Col0	    : COLOR0;
  float2 texcoords  : TEXCOORD0;
  float4 PT3D       : TEXCOORD1;
  float3 normale    : TEXCOORD2;
};

/********************************************************************************/

float4 fpSPSeul(in vertexOutputsTEX IN,
		uniform sampler3D textureSP,
		uniform float3 centreSP[NB_SOURCES],
		uniform float fluctuationIntensite[NB_SOURCES],
		uniform float2 lazimut_lzenith[NB_SOURCES],
/* 		uniform float4x4 TextureSPMatrix, */
		uniform float incr) : COLOR
{
  // calcul de l'intensite d'eclairage stockee dans la texture du solide photometrique
  
  // application de la rotation du SP selon l'inclinaison de la flamme
/*   IN.PT3D = mul(TextureSPMatrix, IN.PT3D); */
  
  float3 point,texcoordsSP;
  float color, r, theta, phi, ColorSP, attenuation;
  float rtex=0;
  for (int i = 0; i < NB_SOURCES; i++) {
    // translation inverse du centre du SP
    point = IN.PT3D.xyz - centreSP[i];
    // passage des coord. cartesiennes (x,y,z) en coord. spheriques (r,theta,phi)
    // attention y est suppose etre la hauteur et z la profondeur
    r = length(point.xyz);
    theta = acos(point.y / r);
    phi = atan2(point.z,point.x);
    
    // Les coordonnees de textures doivent etre utilisees en fonction du sens de codage de la texture
    // On divise par la taille max de la texture en 2D (xy) pour avoir entre 0 et 1
    texcoordsSP = float3(phi * lazimut_lzenith[i].x, theta * lazimut_lzenith[i].y, rtex);
    
    // recuperation de l'intensite du fragment
    ColorSP = tex3D(textureSP, texcoordsSP).x;
    
    // attenuation de l'intensite en fonction de la distance
/*     attenuation = 3.0/r; */
/*     if(attenuation < 1.0) */
/*       ColorSP *= attenuation; */
    // attenuation de l'intensite en fonction de la flamme
    ColorSP *= fluctuationIntensite[i];
    
    color += ColorSP;
    rtex += incr;
  }
  color = color / NB_SOURCES;
  return float4(color.rrr,1.0);
}

/********************************************************************************/

float4 fpSPTEX(in vertexOutputsTEX IN,
	       uniform sampler2D textureFichierOBJ,
	       uniform sampler3D textureSP,
	       uniform float3 centreSP[NB_SOURCES],
	       uniform float fluctuationIntensite[NB_SOURCES],
	       uniform float2 lazimut_lzenith[NB_SOURCES],
	       uniform float incr,
/* 	       uniform float4x4 TextureSPMatrix, */
	       uniform int isTextured) : COLOR
{
/*   if(dot(IN.normale,IN.PT3D.xyz) > 0.15) */
/*     discard; */
  // Couleur de la flamme (en dur pour l'instant)
  float4 CouleurFlamme = float4(R,G,B,1.0);
  
  // application de la rotation du SP selon l'inclinaison de la flamme
  /* IN.PT3D = mul(TextureSPMatrix, IN.PT3D); */
  
  float4 colorTex;
  // calcul de l'intensite d'eclairage stockee dans la texture du solide photometrique
  if(isTextured)
    // couleur de la texture de l'objet codee dans le fichier OBJ
    colorTex = tex2D(textureFichierOBJ, IN.texcoords);
  else
    colorTex = float4(1.0,1.0,1.0,1.0);
  
  float3 point,texcoordsSP,direction;
  float result, color, r, theta, phi, ColorSP, attenuation, cosSN;
  /* Les normales sont normalisées dans le programme grâce à glEnable (GL_NORMALIZE) */
  /*   float3 normale = normalize(IN.normale); */
  
  float rtex=0;

  for (int i = 0; i < NB_SOURCES; i++) {
    // Calcul de la direction du point3D vers le centre du SP
    direction = centreSP[i] - IN.PT3D.xyz;
    direction = normalize(direction);
    // - cos de l'angle entre la direction de la source et la normale au point
    cosSN = dot(direction,IN.normale);
    
/*     // passage des coord. cartesiennes (x,y,z) en coord. spheriques (r,theta,phi) */
/*     // attention y est suppose etre la hauteur et z la profondeur */
    r = length(direction.xyz);
    theta=acos(-direction.y );
/*     phi=atan2(point.z,point.x); */
    
    // Les coordonnees de textures doivent etre utilisees en fonction du sens de codage de la texture
/*     texcoordsSP = float3(phi * lazimut_lzenith[i].x, theta * lazimut_lzenith[i].y, rtex); */
    
/*     // recuperation de l'intensite du fragment */
/*     ColorSP = tex3D(textureSP, texcoordsSP).x; */
    ColorSP = theta;
    
    // attenuation de l'intensite en fonction de l'angle d'eclairage
    ColorSP *= cosSN;
    // attenuation de l'intensite en fonction de la distance
    attenuation = 1.0/r;
    //    if(attenuation < 1.0)
      ColorSP *= attenuation;
    // attenuation de l'intensite en fonction de la flamme
    ColorSP *= fluctuationIntensite[i];
    
    color += ColorSP;
    rtex += incr;
  }
  color = color / NB_SOURCES;
  // melange de la couleur de l'objet, de sa texture et de l'intensite
  return colorTex * float4(color.rrr,1.0) * CouleurFlamme * IN.Col0;
}
